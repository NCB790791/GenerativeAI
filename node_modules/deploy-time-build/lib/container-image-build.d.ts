import { IVpc } from 'aws-cdk-lib/aws-ec2';
import { IRepository } from 'aws-cdk-lib/aws-ecr';
import { DockerImageAssetProps } from 'aws-cdk-lib/aws-ecr-assets';
import { IGrantable, IPrincipal } from 'aws-cdk-lib/aws-iam';
import { DockerImageCode } from 'aws-cdk-lib/aws-lambda';
import { Construct } from 'constructs';
export interface ContainerImageBuildProps extends DockerImageAssetProps {
    /**
     * The tag when to push the image
     * @default use assetHash as tag
     */
    readonly tag?: string;
    /**
     * The ECR repository to push the image.
     * @default create a new ECR repository
     */
    readonly repository?: IRepository;
    /**
     * Use zstd for compressing a container image.
     * @default false
     */
    readonly zstdCompression?: boolean;
    /**
     * The VPC where your build job will be deployed.
     * This VPC must have private subnets with NAT Gateways.
     *
     * Use this property when you want to control the outbound IP addresses that base images are pulled from.
     * @default No VPC used.
     */
    readonly vpc?: IVpc;
}
/**
 * Build a container image and push it to an ECR repository on deploy-time.
 */
export declare class ContainerImageBuild extends Construct implements IGrantable {
    private readonly props;
    readonly grantPrincipal: IPrincipal;
    readonly repository: IRepository;
    readonly imageTag: string;
    constructor(scope: Construct, id: string, props: ContainerImageBuildProps);
    /**
     * Get the instance of {@link DockerImageCode} for a Lambda function image.
     */
    toLambdaDockerImageCode(): DockerImageCode;
    /**
     * Get the instance of {@link ContainerImage} for an ECS task definition.
     */
    toEcsDockerImageCode(): import("aws-cdk-lib/aws-ecs").EcrImage;
    private getImageHash;
    private getDockerBuildCommand;
}
